
import tkinter as tk
import random
import json
import os

class EscapeGame:
    def __init__(self, root):
        self.root = root
        self.root.title("Escape Game")
        self.root.geometry("400x300")
        self.games = ["guess_number", "pattern_memory", "lock_combination"]
        self.completed_games = []
        self.current_game = None
        self.game_data = {}
        self.save_file = "escape_game_save.json"

        self.symbols = ["@", "#", "$", "%", "&"]
        self.lock_code = [random.randint(0, 9) for _ in range(3)]

        self.show_main_menu()

    def show_main_menu(self):
        self.clear_screen()
        title = tk.Label(self.root, text="Escape Game", font=("Helvetica", 18))
        title.pack(pady=10)

        instructions = tk.Label(self.root, text="Choose a game to start:")
        instructions.pack(pady=10)

        btn1 = tk.Button(self.root, text="Guess the Number", command=lambda: self.start_game("guess_number"))
        btn1.pack(pady=5)
        btn2 = tk.Button(self.root, text="Pattern Memory", command=lambda: self.start_game("pattern_memory"))
        btn2.pack(pady=5)
        btn3 = tk.Button(self.root, text="Lock Combination", command=lambda: self.start_game("lock_combination"))
        btn3.pack(pady=5)

        if os.path.exists(self.save_file):
            load_button = tk.Button(self.root, text="Load Game", command=self.load_game)
            load_button.pack(pady=10)

        exit_button = tk.Button(self.root, text="Exit Game", command=self.exit_game)
        exit_button.pack(pady=10)

    def clear_screen(self):
        for widget in self.root.winfo_children():
            widget.destroy()

    def start_game(self, game_name):
        self.current_game = game_name
        if game_name == "guess_number":
            self.guess_number_game()
        elif game_name == "pattern_memory":
            self.pattern_memory_game()
        elif game_name == "lock_combination":
            self.lock_combination_game()

    # ----------------- GUESS THE NUMBER -----------------
    def guess_number_game(self):
        self.clear_screen()
        self.target_number = random.randint(1, 10)
        self.attempts = 5

        tk.Label(self.root, text="Guess the number (1â€“10)").pack()
        self.guess_entry = tk.Entry(self.root)
        self.guess_entry.pack()

        self.guess_feedback = tk.Label(self.root, text="")
        self.guess_feedback.pack()

        tk.Button(self.root, text="Submit", command=self.check_guess).pack(pady=5)
        tk.Button(self.root, text="Exit Game", command=self.exit_game).pack(pady=5)

    def check_guess(self):
        try:
            guess = int(self.guess_entry.get())
        except ValueError:
            self.guess_feedback.config(text="Enter a valid number.")
            return

        self.attempts -= 1
        if guess == self.target_number:
            self.clear_screen()
            tk.Label(self.root, text="You did it! You guessed the number!").pack(pady=10)
            self.root.after(2000, self.complete_game)
        elif self.attempts == 0:
            self.guess_feedback.config(text="Out of attempts! Try again.")
            self.guess_number_game()
        else:
            hint = "Higher!" if guess < self.target_number else "Lower!"
            self.guess_feedback.config(text=f"{hint} Attempts left: {self.attempts}")

    # ----------------- PATTERN MEMORY -----------------
    def pattern_memory_game(self):
        self.clear_screen()
        self.pattern = random.choices(self.symbols, k=2)
        self.pattern_label = tk.Label(self.root, text="Memorize this pattern:", font=('Helvetica', 12))
        self.pattern_label.pack(pady=5)

        self.display = tk.Label(self.root, text=' '.join(self.pattern), font=('Helvetica', 16))
        self.display.pack(pady=5)

        self.root.after(2000, self.hide_pattern)

    def hide_pattern(self):
        self.display.config(text="")
        self.pattern_label.config(text="Repeat the pattern:")

        self.selected_symbols = []

        self.symbol_buttons = []
        for symbol in self.symbols:
            btn = tk.Button(self.root, text=symbol, width=5,
                            command=lambda s=symbol: self.select_symbol(s))
            btn.pack(pady=2)
            self.symbol_buttons.append(btn)

        self.submit_btn = tk.Button(self.root, text="Submit", command=self.check_pattern)
        self.submit_btn.pack(pady=10)

        exit_btn = tk.Button(self.root, text="Exit Game", command=self.exit_game)
        exit_btn.pack(pady=5)

    def select_symbol(self, symbol):
        if len(self.selected_symbols) < 2:
            self.selected_symbols.append(symbol)

    def check_pattern(self):
        for btn in self.symbol_buttons:
            btn.destroy()
        self.submit_btn.destroy()
        if self.selected_symbols == self.pattern:
            self.clear_screen()
            tk.Label(self.root, text="You did it! You remembered the pattern!").pack(pady=10)
            self.root.after(2000, self.complete_game)
        else:
            self.pattern_memory_game()

    # ----------------- LOCK COMBINATION -----------------
    def lock_combination_game(self):
        self.clear_screen()
        self.lock_code = [random.randint(0, 9) for _ in range(3)]

        tk.Label(self.root, text="Guess the 3-digit lock combination").pack()
        self.comb_entry = tk.Entry(self.root)
        self.comb_entry.pack()

        self.comb_feedback = tk.Label(self.root, text="")
        self.comb_feedback.pack()

        tk.Button(self.root, text="Submit", command=self.check_combination).pack(pady=5)
        tk.Button(self.root, text="Exit Game", command=self.exit_game).pack(pady=5)

    def check_combination(self):
        guess = self.comb_entry.get()
        if len(guess) != 3 or not guess.isdigit():
            self.comb_feedback.config(text="Enter a 3-digit number.")
            return

        guess_digits = [int(d) for d in guess]
        feedback = []
        for i in range(3):
            if guess_digits[i] == self.lock_code[i]:
                feedback.append(f"Digit {i+1} correct")
        if len(feedback) == 3:
            self.clear_screen()
            tk.Label(self.root, text="You did it! You opened the lock!").pack(pady=10)
            self.root.after(2000, self.complete_game)
        else:
            self.comb_feedback.config(text="; ".join(feedback))

    # ----------------- COMPLETION & SAVE -----------------
    def complete_game(self):
        self.completed_games.append(self.current_game)
        self.clear_screen()
        tk.Label(self.root, text="Please save your progress.").pack(pady=10)
        self.save_button = tk.Button(self.root, text="Save Game", command=self.save_game)
        self.save_button.pack(pady=10)

    def save_game(self):
        save_data = {
            "completed_games": self.completed_games,
            "remaining_games": [g for g in self.games if g not in self.completed_games]
        }
        with open(self.save_file, "w") as f:
            json.dump(save_data, f)

        self.save_button.config(state=tk.DISABLED)
        tk.Label(self.root, text="Game saved!").pack()
        self.root.after(2000, self.show_continue_screen)

    def show_continue_screen(self):
        self.clear_screen()
        tk.Label(self.root, text="Would you like to continue?", font=('Helvetica', 14)).pack(pady=20)
        tk.Button(self.root, text="Continue", command=self.next_game).pack(pady=10)
        tk.Button(self.root, text="Exit Game", command=self.exit_game).pack(pady=10)

    def next_game(self):
        remaining = [g for g in self.games if g not in self.completed_games]
        if not remaining:
            self.clear_screen()
            tk.Label(self.root, text="Congratulations! You escaped!").pack(pady=20)
            tk.Button(self.root, text="Exit Game", command=self.exit_game).pack(pady=10)
        else:
            next_game = random.choice(remaining)
            self.start_game(next_game)

    def load_game(self):
        with open(self.save_file, "r") as f:
            data = json.load(f)
        self.completed_games = data.get("completed_games", [])
        self.next_game()

    def exit_game(self):
        self.root.destroy()


# Run the game
if __name__ == "__main__":
    root = tk.Tk()
    game = EscapeGame(root)
    root.mainloop()
